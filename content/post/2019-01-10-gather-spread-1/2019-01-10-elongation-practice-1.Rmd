---
title: 'Time to gather, time to spread. Part 1.'
author: Andriy Koval
date: '2019-01-10'
slug: elonongation-practice-1
categories:
  - R
  - data manipulation
tags:
  - tidy data
header:
  caption: 'Gather a single variable'
  image: ''
  preview: yes
---
<!-- These two chunks should be added in the beginning of every .Rmd that you want to source an .R script -->
<!--  The 1st mandatory chunck  -->
<!--  Set the working directory to the repository's base directory -->
```{r, echo=F, message=F} 
#Don't combine this call with any other chunk 
# cat("Working directory: ", getwd()) # check where you are
  library(knitr)
# Rmd is in "./reports/reportA/reportA.Rmd", but now the root is "./"
  knitr::opts_knit$set(root.dir='../../../') 
```

<!--  The 2nd mandatory chunck  -->
<!-- Set the report-wide options, and point to the external code file. -->
```{r set_options, echo=F}
# set options shared by all chunks
opts_chunk$set(
  results='show', 
  message = TRUE,
  comment = NA, 
  tidy = FALSE,
  fig.height = 4, 
  fig.width = 5.5, 
  out.width = "550px",
  fig.path = 'figure_rmd/',     
  dev = "png",
  dpi = 400
  # fig.path = 'figure_pdf/',     
  # dev = "pdf"#,
  # dev.args=list(pdf = list(colormodel = 'cmyk'))
)
echoChunks <- TRUE
options(width=120) #So the output is 50% wider than the default.
# connect to the file with the underlying R script  
read_chunk("./content/post/2019-01-10-gather-spread-1/2019-01-10-elongation-practice-1.R") 
```

##TL;DR
A quick demonstration of transforming data from wide to long format using`tidyr::gather()` and `tidyr::spread()` functions. Fully reproducible example with a simple dataset.

Packages used in this demonstration:
<!-- Load 'sourced' R files.  Suppress the output when loading packages. --> 
```{r load-packages, echo=echoChunks, message=FALSE}
```


```{r load-sources, echo=echoChunks, message=FALSE}
```

```{r declare-globals, echo=echoChunks, results='show', message=FALSE}
```


```{r, echo=echoChunks, message=FALSE}
```

<!-- Load the datasets.   -->
```{r load-data, echo=FALSE, results='show', message=FALSE}
```

# I. Exposition 

Consider the following dataset that captures bullying measure for three respondents over several waves of observation:
<!-- Inspect the datasets.   -->
```{r inspect-data, echo=echoChunks, results='show', message=FALSE}
```
Notice that the data set is said to be _wide with respect to wave_. The names of certain columns (e.g. `AGE_2`, `BULLYING_4`) store information both about the _name_ of the measure (`AGE`,`BULLYING`) and the _wave_ at which these measures were taken (`2`,`4`). This violates the (1) of tidy data definition (see [R for Data Science, 12.2](https://r4ds.had.co.nz/tidy-data.html))

>
1. Each variable must have its own column.
2. Each observation must have its own row.
3. Each value must have its own cell.
  
__GOAL__ This post will demonstrate how to transform this data set into _long form with respect to wave_, creating three separate variables: `age`, `bullying`, and `wave`.  
Let's beging! 

# II. Gather a single variable 
 
To demonstrate the essential logic of `tidyr::gather()`, let's simplify the data even further, leaving only what is necessary to understand the mechanics of the tranformations:
```{r scenario-1-chunk-1, echo=echoChunks, results='show', message=FALSE}
```
The `tidyr::gather()` always does the same thing: it takes _many columns_ and gathers it into _two_ columns. It will always be only __TWO__ columns. We call one column a `value` column, because it stores the _value_ of the new variables (often numeric). We call another column a `key` column because it stores the _key_ to understanding what those values represent. 

 Let's inspect this operation:
```{r scenario-1-chunk-2, echo=echoChunks, results='show', message=FALSE}
```
This data is still NOT tidy, because the column `key` stores the values for both the names of the measure (`AGE`) and the indicator of the wave at which the measure was taken (`0`, `1`, `2`, and `3`).  However, now we can separate these measures by splitting these character values where they are united by an underscore (`_`).

```{r scenario-1-chunk-3, echo=echoChunks, results='show', message=FALSE}
```
Notice that we use a regular expression `AGE_(\\d+)` with the `gsub` function to match `AGE_` literally and replace the value from the column `key` with the first capturing group (`\\1`) and store however many digits (`\\d+`) representing the wave in the new variable `wave`. There are many ways to accomplish this operation and, yes, resorting to [regular expressions](https://www.regular-expressions.info/) may be an overkill in this particular instance. But we do it nonetheless for demonstration purposes (there are many reason [why you should learn regular expressions](https://blog.patricktriest.com/you-should-learn-regex/))

```{r scenario-1-chunk-4, echo=echoChunks, results='show', message=FALSE}
```
Finally, we can assemble these steps into a single call:
```{r scenario-1-chunk-5, echo=echoChunks, results='show', message=FALSE}
```

This script still have some room for improvement. For example, notice that we have spelled out the names of the "wide" variables in the `tidyr::gather()` call:
> AGE_0, AGE_1, AGE_2, AGE_3 

We can replace it with a more elegant
> paste0("AGE_",0:3)

However, this will not work if we were to "gather" the  `BULLYING` variables, because they miss the index `3`. 
```{r scenario-1-chunk-6, echo=echoChunks, results='show', message=FALSE}
```
We will discuss a better strategy for selecting variables for "gathering" in the subsequent post. 



